import { useState, useEffect, useRef, useMemo } from 'react';
import axios from 'axios';
import Link from 'next/link';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import 'katex/dist/katex.min.css';
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';

const WebsiteAssistant = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const [abortController, setAbortController] = useState(null);
  const [editingMessageId, setEditingMessageId] = useState(null);
  const [editedContent, setEditedContent] = useState('');
  const [settings, setSettings] = useState({
    apiEndpoint: 'https://api.example.com/v1/chat/completions',
    apiKey: '',
    defaultModel: 'gpt-3.5-turbo',
    streamOutput: true,
    // 历史消息管理相关设置
    messageHistoryLimit: 10, // 默认每次请求附带10条历史消息
    messageCompressionThreshold: 2000, // 字符数阈值，超过则压缩
    enableHistorySummary: false, // 是否启用历史摘要功能
    historySummaryPrompt: '请总结前面的对话要点，用于后续对话的上下文参考。请简明扼要，不要超过200字。', // 生成摘要的提示词
    namingModel: 'gpt-3.5-turbo', // 用于自动命名对话的模型，默认使用GPT-3.5 Turbo
    autoNameConversation: true // 是否自动命名对话
  });
  const [currentView, setCurrentView] = useState('chat'); // 'chat', 'settings', 'history'
  const [conversations, setConversations] = useState([]);
  const [currentConversationId, setCurrentConversationId] = useState(null);
  const [models, setModels] = useState([
    { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' },
    { id: 'gpt-4', name: 'GPT-4' }
  ]);
  const [selectedModel, setSelectedModel] = useState(null);
  const [newModelName, setNewModelName] = useState('');
  const [newModelId, setNewModelId] = useState('');
  const [showApiKey, setShowApiKey] = useState(false);
  const [historyProcessingStatus, setHistoryProcessingStatus] = useState({
    compressed: false,
    summarized: false,
    limitApplied: false,
    originalCount: 0,
    processedCount: 0
  });
  
  const messagesEndRef = useRef(null);
  const inputRef = useRef(null);

  // 添加一个状态标记是否正在手动滚动
  const [isManualScrolling, setIsManualScrolling] = useState(false);
  // 添加一个标记，记录视图切换到对话的情况
  const [viewChangedToChat, setViewChangedToChat] = useState(false);

  // 监听滚动事件，避免手动滚动时自动滚动干扰
  useEffect(() => {
    const container = document.querySelector('.overflow-y-auto');
    
    const handleScroll = () => {
      // 当用户手动滚动时，暂时禁用自动滚动
      setIsManualScrolling(true);
      
      // 如果用户滚动到接近底部，重新启用自动滚动
      if (container) {
        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
        if (isNearBottom) {
          setIsManualScrolling(false);
        }
      }
      
      // 用户停止滚动一段时间后，重置状态
      clearTimeout(window.scrollTimeout);
      window.scrollTimeout = setTimeout(() => {
        if (container) {
          const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
          if (isNearBottom) {
            setIsManualScrolling(false);
          }
        }
      }, 1000);
    };
    
    if (container) {
      container.addEventListener('scroll', handleScroll);
    }
    
    return () => {
      if (container) {
        container.removeEventListener('scroll', handleScroll);
      }
      clearTimeout(window.scrollTimeout);
    };
  }, []);

  // 加载设置
  useEffect(() => {
    const savedSettings = localStorage.getItem('assistantSettings');
    if (savedSettings) {
      setSettings(JSON.parse(savedSettings));
    }
    
    // 加载模型列表
    const savedModels = localStorage.getItem('assistantModels');
    if (savedModels) {
      setModels(JSON.parse(savedModels));
    }
    
    // 加载历史对话
    const savedConversations = localStorage.getItem('assistantConversations');
    if (savedConversations) {
      setConversations(JSON.parse(savedConversations));
    }
    
    // 加载当前对话
    const currentId = localStorage.getItem('currentConversationId');
    if (currentId) {
      setCurrentConversationId(currentId);
      const currentConversation = JSON.parse(savedConversations)?.find(c => c.id === currentId);
      if (currentConversation) {
        setMessages(currentConversation.messages);
        setSelectedModel(currentConversation.model || settings.defaultModel);
      }
    } else {
      setSelectedModel(settings.defaultModel);
    }
  }, []);

  // 保存设置到本地存储
  useEffect(() => {
    localStorage.setItem('assistantSettings', JSON.stringify(settings));
  }, [settings]);
  
  // 保存模型列表到本地存储
  useEffect(() => {
    localStorage.setItem('assistantModels', JSON.stringify(models));
  }, [models]);
  
  // 保存对话到本地存储
  useEffect(() => {
    if (conversations.length > 0) {
      localStorage.setItem('assistantConversations', JSON.stringify(conversations));
    }
  }, [conversations]);
  
  // 保存当前对话ID
  useEffect(() => {
    if (currentConversationId) {
      localStorage.setItem('currentConversationId', currentConversationId);
    }
  }, [currentConversationId]);

  // 添加键盘快捷键监听
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Ctrl + L 快捷键切换侧边栏
      if (e.ctrlKey && e.key === 'l') {
        e.preventDefault();
        setIsOpen(prev => !prev);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // 添加一个监视当前视图变化的效果
  useEffect(() => {
    // 当视图切换到聊天视图时
    if (currentView === 'chat') {
      setViewChangedToChat(true);
      // 短暂延迟后滚动到底部
      setTimeout(() => {
        const container = document.querySelector('.overflow-y-auto');
        if (container && messages.length > 0) {
          // 确保滚动到底部，使用滚动高度而不是ref
          container.scrollTop = container.scrollHeight;
          // 也可以使用 messagesEndRef，但确保滚动动作是流畅的
          messagesEndRef.current?.scrollIntoView({ behavior: 'auto' });
        }
        // 延长视图切换状态的保持时间，确保有足够时间完成滚动
        setTimeout(() => {
          setViewChangedToChat(false);
        }, 300);
      }, 150);
    }
  }, [currentView, messages.length]);

  // 自动滚动到底部
  useEffect(() => {
    if (messages.length > 0) {
      // 使用 requestAnimationFrame 确保在布局完成后再滚动
      requestAnimationFrame(() => {
        const container = document.querySelector('.overflow-y-auto');
        // 只有在当前没有滚动操作时才执行自动滚动，或者是视图切换到对话时
        if (container && (!isManualScrolling || viewChangedToChat)) {
          // 使用平滑滚动，但确保不会在流式输出时频繁触发
          if (!isStreaming) {
            messagesEndRef.current?.scrollIntoView({ behavior: viewChangedToChat ? 'auto' : 'smooth' });
          } else {
            // 流式输出时直接滚动到底部，不使用动画
            container.scrollTop = container.scrollHeight;
          }
        }
      });
    }
  }, [messages, isStreaming, viewChangedToChat, isManualScrolling]);

  // 打开侧边栏时聚焦输入框
  useEffect(() => {
    if (isOpen && currentView === 'chat') {
      setTimeout(() => {
        inputRef.current?.focus();
      }, 100);
    }
  }, [isOpen, currentView]);

  const handleSendMessage = async () => {
    if (!input.trim() || isLoading) return;
    
    // 检查是否有当前对话，如果没有则创建新对话
    if (!currentConversationId) {
      createNewConversation();
    }
    
    const userMessage = {
      role: 'user',
      content: input.trim(),
      timestamp: new Date().toISOString(),
    };
    
    setMessages(prev => [...prev, userMessage]);
    setInput('');
    
    // 重置输入框高度
    if (inputRef.current) {
      inputRef.current.style.height = 'auto';
      inputRef.current.style.height = '38px';
    }
    
    setIsLoading(true);
    
    // 创建一个新的 AbortController 实例
    const controller = new AbortController();
    setAbortController(controller);
    
    try {
      // 更新当前对话
      updateConversation([...messages, userMessage], selectedModel);
      
      // 处理历史消息，应用限制和压缩
      const processedMessages = await processMessageHistory(
        [...messages, userMessage],
        settings.messageHistoryLimit,
        settings.messageCompressionThreshold,
        settings.enableHistorySummary,
        settings.historySummaryPrompt
      );
      
      if (settings.streamOutput) {
        // 创建助手消息占位符
        const assistantMessageId = Date.now().toString();
        const assistantMessage = {
          id: assistantMessageId,
          role: 'assistant',
          content: '',
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, assistantMessage]);
        setIsStreaming(true);
        
        // 使用流式输出
        try {
          const response = await fetch('/api/assistant/chat-stream', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              messages: processedMessages, // 使用处理过的消息
              model: selectedModel,
              apiEndpoint: settings.apiEndpoint,
              apiKey: settings.apiKey,
            }),
            signal: controller.signal
          });
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let done = false;
          let accumulatedContent = '';
          
          // 添加防抖动处理
          let lastUpdateTime = 0;
          const UPDATE_INTERVAL = 50; // 50毫秒内最多更新一次UI
          
          while (!done) {
            const { value, done: doneReading } = await reader.read();
            done = doneReading;
            
            if (done) break;
            
            const chunk = decoder.decode(value, { stream: true });
            accumulatedContent += chunk;
            
            // 使用防抖动更新，降低重绘频率
            const now = Date.now();
            if (now - lastUpdateTime > UPDATE_INTERVAL) {
              lastUpdateTime = now;
              
              // 使用优化后的函数更新内容
              updateStreamingContent(assistantMessageId, accumulatedContent);
            }
          }
          
          // 确保最后一次更新始终执行
          updateStreamingContent(assistantMessageId, accumulatedContent);
          
          // 更新对话历史
          setMessages(prev => {
            const updated = prev.map(msg => 
              msg.id === assistantMessageId
                ? { ...msg, content: accumulatedContent }
                : msg
            );
            updateConversation([...messages, userMessage, ...updated.filter(m => m.id === assistantMessageId)], selectedModel);
            return updated;
          });
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('用户取消了请求');
            // 更新消息，指示请求被取消
            setMessages(prev => 
              prev.map(msg => 
                msg.id === assistantMessageId
                  ? { ...msg, content: msg.content + '\n\n[用户已停止生成]' }
                  : msg
              )
            );
          } else {
            throw error; // 重新抛出非取消错误
          }
        }
      } else {
        // 非流式输出，保持原有逻辑
        const response = await axios.post('/api/assistant/chat', {
          messages: processedMessages, // 使用处理过的消息
          model: selectedModel,
          apiEndpoint: settings.apiEndpoint,
          apiKey: settings.apiKey,
        }, { signal: controller.signal });
        
        const assistantMessage = {
          role: 'assistant',
          content: response.data.content,
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, assistantMessage]);
        
        // 更新当前对话
        updateConversation([...messages, userMessage, assistantMessage], selectedModel);
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('用户取消了请求');
      } else {
        console.error('Error sending message:', error);
        
        // 添加错误消息
        const errorMessage = {
          role: 'system',
          content: `发生错误: ${error.message || '未知错误'}`,
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, errorMessage]);
        
        // 更新当前对话
        updateConversation([...messages, userMessage, errorMessage], selectedModel);
      }
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
      setAbortController(null);
    }
  };

  const handleAbortRequest = () => {
    if (abortController) {
      abortController.abort();
    }
  };

  const createNewConversation = () => {
    const newId = `conv-${Date.now()}`;
    const newConversation = {
      id: newId,
      title: `新对话`, // 在自动命名完成前显示为"新对话"
      createdAt: new Date().toISOString(),
      messages: [],
      model: selectedModel || settings.defaultModel,
      isNamed: false // 标记是否已经命名
    };
    
    setConversations(prev => [newConversation, ...prev]); // 将新对话放在最前面
    setCurrentConversationId(newId);
    setMessages([]);
    
    return newId;
  };
  
  const updateConversation = (updatedMessages, model = selectedModel) => {
    const conversation = conversations.find(conv => conv.id === currentConversationId);
    
    // 检查是否需要自动命名对话
    if (conversation && 
        settings.autoNameConversation && 
        !conversation.isNamed && 
        updatedMessages.length >= 2 && 
        updatedMessages.some(msg => msg.role === 'assistant')) {
      // 有足够的消息内容进行命名
      generateConversationName(updatedMessages);
    }
    
    setConversations(prev => 
      prev.map(conv => 
        conv.id === currentConversationId 
          ? { ...conv, messages: updatedMessages, model } 
          : conv
      )
    );
  };
  
  const switchConversation = (id) => {
    const conversation = conversations.find(c => c.id === id);
    if (conversation) {
      setCurrentConversationId(id);
      setMessages(conversation.messages);
      setSelectedModel(conversation.model || settings.defaultModel);
      // 切换到聊天视图
      setCurrentView('chat');
      // 标记视图切换，用于触发滚动
      setViewChangedToChat(true);
      // 强制滚动到底部
      setTimeout(() => {
        const container = document.querySelector('.overflow-y-auto');
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      }, 100);
    }
  };

  const handleChangeModel = (modelId) => {
    setSelectedModel(modelId);
    // 更新当前对话的模型
    if (currentConversationId) {
      updateConversation(messages, modelId);
    }
  };

  const addNewModel = () => {
    if (newModelId.trim() && newModelName.trim()) {
      const newModel = {
        id: newModelId.trim(),
        name: newModelName.trim()
      };
      
      setModels(prev => [...prev, newModel]);
      setNewModelId('');
      setNewModelName('');
    }
  };

  const removeModel = (id) => {
    // 不允许删除当前正在使用的模型
    if (selectedModel === id || settings.defaultModel === id) {
      alert('无法删除正在使用的模型');
      return;
    }
    
    setModels(prev => prev.filter(model => model.id !== id));
  };

  const saveSettings = () => {
    setSettings(prev => ({
      ...prev,
      defaultModel: selectedModel || prev.defaultModel
    }));
    alert('设置已保存');
  };

  const deleteConversation = (id) => {
    if (window.confirm('确定要删除此对话吗？此操作无法撤销。')) {
      const updatedConversations = conversations.filter(conv => conv.id !== id);
      setConversations(updatedConversations);
      
      // 如果删除的是当前对话，切换到新建对话状态
      if (currentConversationId === id) {
        setCurrentConversationId(null);
        setMessages([]);
        setCurrentView('chat');
        setViewChangedToChat(true); // 确保滚动到底部
      }
    }
  };

  // 处理复制消息内容
  const handleCopyMessage = (content, event) => {
    // 阻止事件冒泡，避免干扰其他按钮
    if (event) {
      event.stopPropagation();
    }
    
    // 获取当前点击的按钮元素
    const button = event?.currentTarget;
    
    navigator.clipboard.writeText(content)
      .then(() => {
        if (button) {
          // 添加"已复制"样式
          button.classList.add('copied');
          const originalText = button.textContent;
          button.textContent = "✓ 已复制";
          
          // 2秒后恢复
          setTimeout(() => {
            button.classList.remove('copied');
            button.textContent = originalText;
          }, 2000);
        }
      })
      .catch((err) => {
        console.error('复制失败:', err);
        alert('复制失败，请手动选择文本复制');
      });
  };

  // 处理编辑消息
  const handleEditMessage = (message) => {
    setEditingMessageId(message.id || message.timestamp);
    setEditedContent(message.content);
  };

  // 提交编辑后的消息
  const submitEditedMessage = async () => {
    if (!editedContent.trim()) return;

    // 找到正在编辑的消息在数组中的位置
    const messageIndex = messages.findIndex(
      msg => (msg.id || msg.timestamp) === editingMessageId
    );
    if (messageIndex === -1) return;

    // 如果编辑的是用户消息，需要重新生成助手响应
    const isUserMessage = messages[messageIndex].role === 'user';
    
    // 更新消息内容
    const updatedMessages = [...messages];
    updatedMessages[messageIndex] = {
      ...updatedMessages[messageIndex],
      content: editedContent
    };
    
    // 如果编辑的是用户消息，则删除之后的所有消息（因为需要重新生成回复）
    const messagesToKeep = isUserMessage 
      ? updatedMessages.slice(0, messageIndex + 1)
      : updatedMessages;
    
    setMessages(messagesToKeep);
    setEditingMessageId(null);
    setEditedContent('');
    
    // 更新对话历史
    updateConversation(messagesToKeep, selectedModel);
    
    // 如果编辑的是用户消息，自动重新生成回复
    if (isUserMessage) {
      // 在编辑模式下立即发送消息获取新回复
      const editedUserMessage = messagesToKeep[messageIndex];
      setIsLoading(true);
      
      // 创建一个新的 AbortController 实例
      const controller = new AbortController();
      setAbortController(controller);
      
      try {
        // 处理历史消息，应用限制和压缩
        const processedMessages = await processMessageHistory(
          messagesToKeep,
          settings.messageHistoryLimit,
          settings.messageCompressionThreshold,
          settings.enableHistorySummary,
          settings.historySummaryPrompt
        );
        
        if (settings.streamOutput) {
          // 创建助手消息占位符
          const assistantMessageId = Date.now().toString();
          const assistantMessage = {
            id: assistantMessageId,
            role: 'assistant',
            content: '',
            timestamp: new Date().toISOString(),
          };
          
          setMessages(prev => [...prev, assistantMessage]);
          setIsStreaming(true);
          
          // 使用流式输出
          try {
            const response = await fetch('/api/assistant/chat-stream', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                messages: processedMessages, // 使用处理过的消息
                model: selectedModel,
                apiEndpoint: settings.apiEndpoint,
                apiKey: settings.apiKey,
              }),
              signal: controller.signal
            });
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            let accumulatedContent = '';
            
            while (!done) {
              const { value, done: doneReading } = await reader.read();
              done = doneReading;
              
              if (done) break;
              
              const chunk = decoder.decode(value, { stream: true });
              accumulatedContent += chunk;
              
              // 更新消息内容
              setMessages(prev => 
                prev.map(msg => 
                  msg.id === assistantMessageId
                    ? { ...msg, content: accumulatedContent }
                    : msg
                )
              );
            }
            
            // 更新对话历史
            setMessages(prev => {
              const updated = prev.map(msg => 
                msg.id === assistantMessageId
                  ? { ...msg, content: accumulatedContent }
                  : msg
              );
              updateConversation(updated, selectedModel);
              return updated;
            });
            
          } catch (error) {
            if (error.name === 'AbortError') {
              console.log('用户取消了请求');
              // 更新消息，指示请求被取消
              setMessages(prev => 
                prev.map(msg => 
                  msg.id === assistantMessageId
                    ? { ...msg, content: msg.content + '\n\n[用户已停止生成]' }
                    : msg
                )
              );
            } else {
              throw error; // 重新抛出非取消错误
            }
          }
        } else {
          // 非流式输出
          const response = await axios.post('/api/assistant/chat', {
            messages: processedMessages, // 使用处理过的消息
            model: selectedModel,
            apiEndpoint: settings.apiEndpoint,
            apiKey: settings.apiKey,
          }, { signal: controller.signal });
          
          const assistantMessage = {
            role: 'assistant',
            content: response.data.content,
            timestamp: new Date().toISOString(),
          };
          
          setMessages(prev => [...prev, assistantMessage]);
          
          // 更新当前对话
          updateConversation([...messagesToKeep, assistantMessage], selectedModel);
        }
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('用户取消了请求');
        } else {
          console.error('重新生成回复时出错:', error);
          
          // 添加错误消息
          const errorMessage = {
            role: 'system',
            content: `发生错误: ${error.message || '未知错误'}`,
            timestamp: new Date().toISOString(),
          };
          
          setMessages(prev => [...prev, errorMessage]);
          
          // 更新当前对话
          updateConversation([...messagesToKeep, errorMessage], selectedModel);
        }
      } finally {
        setIsLoading(false);
        setIsStreaming(false);
        setAbortController(null);
      }
    }
  };

  // 重新生成助手回复
  const regenerateResponse = async (messageIndex) => {
    // 保存当前滚动位置
    const chatContainer = document.querySelector('.overflow-y-auto');
    const scrollPosition = chatContainer ? chatContainer.scrollTop : 0;
    
    // 设置手动滚动标记，防止自动滚动干扰
    setIsManualScrolling(true);
    
    // 找到要回复的用户消息
    const messagesToKeep = messages.slice(0, messageIndex + 1);
    
    setMessages(messagesToKeep);
    setIsLoading(true);
    
    // 创建一个新的 AbortController 实例
    const controller = new AbortController();
    setAbortController(controller);
    
    try {
      // 更新对话
      updateConversation(messagesToKeep, selectedModel);
      
      // 处理历史消息，应用限制和压缩
      const processedMessages = await processMessageHistory(
        messagesToKeep,
        settings.messageHistoryLimit,
        settings.messageCompressionThreshold,
        settings.enableHistorySummary,
        settings.historySummaryPrompt
      );
      
      if (settings.streamOutput) {
        // 创建助手消息占位符
        const assistantMessageId = Date.now().toString();
        const assistantMessage = {
          id: assistantMessageId,
          role: 'assistant',
          content: '',
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, assistantMessage]);
        
        // 恢复滚动位置，使用更可靠的方式
        setTimeout(() => {
          if (chatContainer) {
            chatContainer.scrollTop = scrollPosition;
            
            // 短暂延迟后再重置手动滚动标记
            setTimeout(() => {
              setIsManualScrolling(false);
            }, 300);
          }
        }, 50);
        
        setIsStreaming(true);
        
        // 使用流式输出
        try {
          const response = await fetch('/api/assistant/chat-stream', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              messages: processedMessages, // 使用处理过的消息
              model: selectedModel,
              apiEndpoint: settings.apiEndpoint,
              apiKey: settings.apiKey,
            }),
            signal: controller.signal
          });
          
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let done = false;
          let accumulatedContent = '';
          
          while (!done) {
            const { value, done: doneReading } = await reader.read();
            done = doneReading;
            
            if (done) break;
            
            const chunk = decoder.decode(value, { stream: true });
            accumulatedContent += chunk;
            
            // 更新消息内容
            setMessages(prev => 
              prev.map(msg => 
                msg.id === assistantMessageId
                  ? { ...msg, content: accumulatedContent }
                  : msg
              )
            );
          }
          
          // 更新对话历史
          setMessages(prev => {
            const updated = prev.map(msg => 
              msg.id === assistantMessageId
                ? { ...msg, content: accumulatedContent }
                : msg
            );
            updateConversation([...messagesToKeep, ...updated.filter(m => m.id === assistantMessageId)], selectedModel);
            return updated;
          });
          
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('用户取消了请求');
            // 更新消息，指示请求被取消
            setMessages(prev => 
              prev.map(msg => 
                msg.id === assistantMessageId
                  ? { ...msg, content: msg.content + '\n\n[用户已停止生成]' }
                  : msg
              )
            );
          } else {
            throw error; // 重新抛出非取消错误
          }
        }
      } else {
        // 非流式输出
        const response = await axios.post('/api/assistant/chat', {
          messages: processedMessages, // 使用处理过的消息
          model: selectedModel,
          apiEndpoint: settings.apiEndpoint,
          apiKey: settings.apiKey,
        }, { signal: controller.signal });
        
        const assistantMessage = {
          role: 'assistant',
          content: response.data.content,
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, assistantMessage]);
        
        // 更新当前对话
        updateConversation([...messagesToKeep, assistantMessage], selectedModel);
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('用户取消了请求');
      } else {
        console.error('重新生成回复时出错:', error);
        
        // 添加错误消息
        const errorMessage = {
          role: 'system',
          content: `发生错误: ${error.message || '未知错误'}`,
          timestamp: new Date().toISOString(),
        };
        
        setMessages(prev => [...prev, errorMessage]);
        
        // 更新当前对话
        updateConversation([...messagesToKeep, errorMessage], selectedModel);
      }
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
      setAbortController(null);
    }
  };

  // 取消消息编辑
  const cancelEdit = () => {
    setEditingMessageId(null);
    setEditedContent('');
  };

  // 处理块级公式，将 \[ \] 转换为 $$ $$
  const processBlockMath = (content) => {
    if (!content) return '';
    
    // 处理 LaTeX 块级公式 \[ \] 格式，转换为 $$ $$ 格式
    let processed = content.replace(/\\\[([\s\S]*?)\\\]/g, '$$$$1$$');
    
    // 处理行内的 \( \) 语法，转换为 $ $ 格式
    processed = processed.replace(/\\\(([\s\S]*?)\\\)/g, '$$$1$');
    
    // 处理已经是 $$ $$ 格式的情况，确保它们被正确解析
    // 先检查它们是否已经被正确识别，如果没有则手动处理
    // 这通常用于处理非标准标记，或确保标记直接被显示为块级公式
    if (processed.match(/\$\$([\s\S]*?)\$\$/g)) {
      // 这种情况下已经是 $$ $$ 格式，无需处理
      // 但我们可以确保它被识别为块级公式，比如加入额外空格等
      processed = processed.replace(/\$\$([\s\S]*?)\$\$/g, (match) => {
        // 确保公式前后有换行
        if (!match.startsWith('\n') && !/\n\s*$/.test(match)) {
          return '\n' + match + '\n';
        }
        return match;
      });
    }
    
    // 确保单行内的 $ 不会被错误解析为多个行内公式
    // 例如 $a$ 和 $b$ 应该是两个独立的公式，而非 $a$ 和 $b$ 之间的所有内容
    processed = processed.replace(/(\$)([^\$]+?)(\$)/g, '$1$2$3');
    
    return processed;
  };
  
  // 优化流式输出内容处理
  const updateStreamingContent = (messageId, content) => {
    setMessages(prev => 
      prev.map(msg => 
        msg.id === messageId
          ? { ...msg, content }
          : msg
      )
    );
  };

  // 添加历史消息处理功能
  const compressMessage = (content, threshold) => {
    if (!content || content.length <= threshold) {
      return content;
    }
    
    // 保留开头和结尾的内容，中间部分截断
    const keepStart = Math.floor(threshold * 0.6); // 保留前60%
    const keepEnd = Math.floor(threshold * 0.4); // 保留后40%
    
    return content.substring(0, keepStart) + 
           `\n\n<div class="compressed-indicator">此消息已压缩，省略了${content.length - threshold}个字符</div>\n\n` + 
           content.substring(content.length - keepEnd);
  };

  // 处理消息历史，限制数量、压缩长消息
  const processMessageHistory = async (messages, limit, compressionThreshold, enableSummary = false, summaryPrompt = '') => {
    if (!messages || messages.length === 0) {
      setHistoryProcessingStatus({
        compressed: false,
        summarized: false,
        limitApplied: false,
        originalCount: 0,
        processedCount: 0
      });
      return [];
    }
    
    // 重置状态
    let processingStatus = {
      compressed: false,
      summarized: false,
      limitApplied: false,
      originalCount: messages.length,
      processedCount: 0
    };
    
    // 第一步：处理历史摘要（如果启用）
    let processedMessages = [...messages];
    let historySummary = null;
    
    if (enableSummary && messages.length > limit + 2) { // 只有当消息数量足够多时才生成摘要
      try {
        // 取前N条消息来生成摘要
        const messagesToSummarize = messages.slice(0, messages.length - limit);
        
        // 创建摘要请求
        historySummary = await generateHistorySummary(messagesToSummarize, summaryPrompt);
        
        if (historySummary) {
          // 如果成功生成摘要，则使用摘要替代早期历史
          processedMessages = [
            { 
              role: 'system', 
              content: `以下是之前对话的摘要：\n${historySummary}\n\n请基于此摘要继续对话。`,
              timestamp: new Date().toISOString()
            },
            ...messages.slice(messages.length - limit)
          ];
          processingStatus.summarized = true;
        }
      } catch (error) {
        console.error('生成历史摘要时出错:', error);
        // 如果摘要生成失败，继续使用限制消息数的方法
      }
    }
    
    // 第二步：如果没有启用摘要或摘要生成失败，则直接限制消息数量
    if (!historySummary && messages.length > limit) {
      processedMessages = messages.slice(Math.max(0, messages.length - limit));
      processingStatus.limitApplied = true;
    }
    
    // 第三步：压缩过长的消息
    let hasCompressed = false;
    processedMessages = processedMessages.map(msg => {
      if (msg.content.length > compressionThreshold) {
        hasCompressed = true;
        return {
          ...msg,
          content: compressMessage(msg.content, compressionThreshold)
        };
      }
      return msg;
    });
    
    processingStatus.compressed = hasCompressed;
    processingStatus.processedCount = processedMessages.length;
    
    // 更新状态
    setHistoryProcessingStatus(processingStatus);
    
    return processedMessages;
  };

  // 生成历史消息摘要
  const generateHistorySummary = async (messages, summaryPrompt) => {
    try {
      // 准备摘要请求
      const summaryMessages = [
        {
          role: 'system',
          content: '你是一个擅长总结对话的助手，你的任务是将对话历史进行简洁的总结，保留关键信息，以便后续模型能够理解对话的上下文。'
        },
        ...messages,
        {
          role: 'user',
          content: summaryPrompt || '请总结前面的对话要点，用于后续对话的上下文参考。请简明扼要，不要超过200字。'
        }
      ];
      
      const response = await axios.post('/api/assistant/chat', {
        messages: summaryMessages,
        model: settings.defaultModel,
        apiEndpoint: settings.apiEndpoint,
        apiKey: settings.apiKey,
      });
      
      return response.data.content;
    } catch (error) {
      console.error('生成摘要时出错:', error);
      return null;
    }
  };

  // 生成对话名称的函数
  const generateConversationName = async (messages) => {
    if (!settings.apiKey || messages.length < 2) return;
    
    try {
      // 准备用于生成名称的消息
      const relevantMessages = messages.slice(0, Math.min(messages.length, 3)); // 使用前三条消息
      
      const namingMessages = [
        {
          role: 'system',
          content: '你是一个对话命名助手。请根据对话内容生成一个简短的标题（不超过15个字），准确反映对话的主题。不要使用引号，不要有任何多余文字，直接返回标题即可。'
        },
        ...relevantMessages,
        {
          role: 'user',
          content: '请为这个对话生成一个简短的标题，不超过15个字，能准确反映我们讨论的主题。'
        }
      ];
      
      // 使用命名模型生成标题，确保使用设置中指定的命名模型
      const response = await axios.post('/api/assistant/chat', {
        messages: namingMessages,
        model: settings.namingModel || 'gpt-3.5-turbo', // 默认使用GPT-3.5 Turbo
        apiEndpoint: settings.apiEndpoint,
        apiKey: settings.apiKey,
      });
      
      if (response.data && response.data.content) {
        // 清理生成的标题（去除可能的引号和多余空格）
        let title = response.data.content.trim();
        title = title.replace(/^["'"「『]|["'"」』]$/g, ''); // 移除可能的引号
        
        // 更新对话标题
        setConversations(prev => 
          prev.map(conv => 
            conv.id === currentConversationId 
              ? { ...conv, title, isNamed: true } 
              : conv
          )
        );
      }
    } catch (error) {
      console.error('生成对话标题时出错:', error);
      // 出错时不处理，保持原有标题
    }
  };

  // 消息组件
  const MessageItem = ({ message, index }) => {
    const isUser = message.role === 'user';
    const isSystem = message.role === 'system';
    const isEditing = (message.id || message.timestamp) === editingMessageId;
    const messageId = message.id || message.timestamp;
    const [showPreview, setShowPreview] = useState(false);
    const [hasRendered, setHasRendered] = useState(false);
    const messageRef = useRef(null);
    
    // 检测消息是否包含压缩标记
    const isCompressed = message.content.includes('<div class="compressed-indicator">');
    
    // 在组件挂载后标记为已渲染，减少布局变化
    useEffect(() => {
      setHasRendered(true);
    }, []);
    
    // 所有非系统消息都可以编辑
    const canEdit = !isSystem;
    // 定义重新生成按钮是否可用 - 对于助手消息，仅当是最后一条助手消息时可重新生成
    const canRegenerate = !isUser && !isSystem && index === messages.length - 1;
    // 判断是否是最后一条用户消息
    const isLastUserMessage = isUser && messages.findIndex(msg => msg.role === 'user' && msg !== message) < index;
    
    // 预处理消息内容，为渲染做准备
    const processedContent = useMemo(() => {
      return processBlockMath(message.content);
    }, [message.content]);
    
    // 保持编辑器光标位置
    const [cursorPosition, setCursorPosition] = useState(null);
    const textareaRef = useRef(null);
    
    // 添加中文输入法的状态控制
    const [isComposing, setIsComposing] = useState(false);
    
    // 在光标位置改变后恢复，但需要避免在输入中文时触发
    useEffect(() => {
      if (isEditing && textareaRef.current && cursorPosition !== null && !isComposing) {
        textareaRef.current.selectionStart = cursorPosition;
        textareaRef.current.selectionEnd = cursorPosition;
      }
    }, [isEditing, cursorPosition, isComposing]);
    
    // 增加焦点监听以确保编辑开始时正确设置光标
    useEffect(() => {
      if (isEditing && textareaRef.current) {
        // 设置初始光标位置在文本末尾
        const textLength = editedContent.length;
        textareaRef.current.selectionStart = textLength;
        textareaRef.current.selectionEnd = textLength;
        setCursorPosition(textLength);
        
        // 延迟一点以确保获得焦点后设置光标
        setTimeout(() => {
          textareaRef.current?.focus();
        }, 50);
      }
    }, [isEditing]);
    
    return (
      <div 
        ref={messageRef}
        className={`relative p-3 rounded-lg max-w-[95%] group ${
          isUser
            ? 'ml-auto bg-blue-500 text-white'
            : isSystem
            ? 'mx-auto bg-yellow-100 text-yellow-800'
            : 'bg-white text-gray-800 shadow'
        } ${isCompressed ? 'border-l-4 border-orange-400' : ''}`}
        style={{
          // 使用固定高度策略减少布局计算
          minHeight: hasRendered ? undefined : isUser ? '50px' : '70px',
          // 使用transform将消息固定到硬件层，减少重绘
          transform: 'translateZ(0)',
          // 防止内容溢出
          overflowWrap: 'break-word',
          wordBreak: 'break-word'
        }}
      >
        {isEditing ? (
          <div className="flex flex-col space-y-2">
            <textarea
              ref={textareaRef}
              value={editedContent}
              onChange={(e) => {
                // 获取当前光标位置
                const textarea = e.target;
                // 记录当前光标位置，但只在非中文输入状态下更新
                if (!isComposing) {
                  setCursorPosition(textarea.selectionStart);
                }
                // 更新编辑内容
                setEditedContent(e.target.value);
              }}
              // 处理中文输入法
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionUpdate={() => {
                // 确保在整个输入过程中保持组合状态
                setIsComposing(true);
              }}
              onCompositionEnd={(e) => {
                // 获取当前光标位置
                const pos = e.target.selectionStart;
                
                // 将isComposing设置为false，但要在下一个事件循环才执行
                // 这样可以确保onChange事件在compositionEnd之后处理时不会错误地更新光标
                setTimeout(() => {
                  setIsComposing(false);
                  
                  // 确保在组合输入完成后保持正确的光标位置
                  if (textareaRef.current) {
                    textareaRef.current.selectionStart = pos;
                    textareaRef.current.selectionEnd = pos;
                    setCursorPosition(pos);
                  }
                }, 0);
              }}
              onClick={(e) => {
                // 点击时更新光标位置
                if (!isComposing) {
                  setCursorPosition(e.target.selectionStart);
                }
              }}
              onKeyUp={(e) => {
                // 键盘操作后也更新光标位置，但避免处理组合键
                if (!isComposing && !e.ctrlKey && !e.altKey && !e.metaKey) {
                  setCursorPosition(e.target.selectionStart);
                }
              }}
              // 添加onSelect事件以处理文本选择
              onSelect={(e) => {
                if (!isComposing) {
                  setCursorPosition(e.target.selectionStart);
                }
              }}
              className="w-full p-2 text-gray-800 bg-white border rounded min-h-[100px]"
              autoFocus
            />
            
            {/* 添加公式预览按钮和预览区域 */}
            <div className="flex items-center">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setShowPreview(!showPreview);
                }}
                className="text-xs bg-gray-200 text-gray-700 px-2 py-1 rounded hover:bg-gray-300"
              >
                {showPreview ? "隐藏预览" : "预览公式"}
              </button>
              {editedContent.includes('\\[') || editedContent.includes('\\(') || editedContent.includes('$') ? (
                <span className="text-xs text-gray-500 ml-2">包含数学公式</span>
              ) : null}
            </div>
            
            {/* 预览区域 */}
            {showPreview && (
              <div className="bg-white border rounded p-3 mt-2">
                <ReactMarkdown
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeRaw, [rehypeKatex, { throwOnError: false, strict: false }]]}
                  className="text-gray-800"
                >
                  {processBlockMath(editedContent)}
                </ReactMarkdown>
              </div>
            )}
            
            <div className="flex justify-end space-x-2">
              <button
                onClick={cancelEdit}
                className="px-2 py-1 text-xs text-gray-600 bg-gray-200 rounded hover:bg-gray-300"
              >
                取消
              </button>
              <button
                onClick={submitEditedMessage}
                className="px-2 py-1 text-xs text-white bg-blue-500 rounded hover:bg-blue-600"
              >
                保存
              </button>
            </div>
          </div>
        ) : (
          <>
            <div className="prose prose-sm max-w-none dark:prose-invert stable-content">
              {isUser ? (
                <ReactMarkdown
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeRaw, [rehypeKatex, { throwOnError: false, strict: false }]]}
                  className="text-white"
                >
                  {processedContent}
                </ReactMarkdown>
              ) : (
                <ReactMarkdown
                  remarkPlugins={[remarkGfm, remarkMath]}
                  rehypePlugins={[rehypeRaw, [rehypeKatex, { throwOnError: false, strict: false }]]}
                  className={isSystem ? 'text-yellow-800' : 'text-gray-800'}
                >
                  {processedContent}
                </ReactMarkdown>
              )}
            </div>
            
            {/* 压缩指示器 */}
            {isCompressed && (
              <div className="mt-1 text-xs bg-orange-100 text-orange-700 p-1 rounded">
                <span role="img" aria-label="压缩">📃</span> 此消息已被压缩以减少token用量
              </div>
            )}
            
            {/* 消息操作按钮区域 */}
            <div className="flex justify-between items-center mt-1 button-container">
              <div className="opacity-0 group-hover:opacity-100 transition-opacity flex flex-wrap space-x-1">
                {/* 复制按钮 - 所有消息都有 */}
                <button
                  onClick={(e) => handleCopyMessage(message.content, e)}
                  className="msg-btn"
                  title="复制"
                >
                  复制
                </button>
                
                {/* 编辑按钮 - 非系统消息都有 */}
                {canEdit && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleEditMessage(message);
                    }}
                    className="msg-btn"
                    title="编辑"
                  >
                    编辑
                  </button>
                )}
                
                {/* 重新生成按钮 - 只有最后一条助手消息有 */}
                {canRegenerate && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      regenerateResponse(index - 1);
                    }}
                    className="msg-btn"
                    title="重新生成"
                    disabled={isLoading}
                  >
                    重新生成
                  </button>
                )}
                
                {/* 用户消息的"重新生成"按钮 */}
                {isUser && index > 0 && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      regenerateResponse(index);
                    }}
                    className="msg-btn"
                    title="重新生成回复"
                    disabled={isLoading}
                  >
                    重新生成
                  </button>
                )}
              </div>
              
              <div className="text-xs opacity-70 text-right">
                {new Date(message.timestamp).toLocaleTimeString()}
              </div>
            </div>
          </>
        )}
      </div>
    );
  };

  // 渲染设置视图
  const renderSettings = () => (
    <div className="flex flex-col h-full overflow-y-auto">
      <div className="p-4 bg-gray-50">
        <h3 className="font-semibold text-lg mb-4">设置</h3>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              API 端点
            </label>
            <input
              type="text"
              value={settings.apiEndpoint}
              onChange={(e) => setSettings(prev => ({ ...prev, apiEndpoint: e.target.value }))}
              placeholder="https://api.example.com/v1/chat/completions"
              className="w-full px-3 py-2 border rounded text-sm"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              API 密钥
            </label>
            <div className="relative">
              <input
                type={showApiKey ? "text" : "password"}
                value={settings.apiKey}
                onChange={(e) => setSettings(prev => ({ ...prev, apiKey: e.target.value }))}
                placeholder="您的 API 密钥"
                className="w-full px-3 py-2 border rounded text-sm pr-10"
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-600 hover:text-gray-800"
                onClick={() => setShowApiKey(!showApiKey)}
              >
                {showApiKey ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                    <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clipRule="evenodd" />
                    <path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z" />
                  </svg>
                )}
              </button>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              默认模型
            </label>
            <select
              value={selectedModel || settings.defaultModel}
              onChange={(e) => setSelectedModel(e.target.value)}
              className="w-full px-3 py-2 border rounded text-sm"
            >
              {models.map(model => (
                <option key={model.id} value={model.id}>
                  {model.name}
                </option>
              ))}
            </select>
          </div>
          
          {/* 模型管理部分 - 直接跟在默认模型后面 */}
          <div className="pt-2">
            <h4 className="font-medium text-gray-700 mb-2">模型管理</h4>
            
            <div className="space-y-2 mb-4 max-h-60 overflow-y-auto border rounded p-2">
              {models.map(model => (
                <div key={model.id} className="flex justify-between items-center p-2 bg-gray-100 rounded">
                  <div>
                    <span className="font-medium">{model.name}</span>
                    <span className="text-sm text-gray-500 ml-2">({model.id})</span>
                  </div>
                  <button
                    onClick={() => removeModel(model.id)}
                    className="text-red-500 hover:text-red-700 text-sm"
                    title="删除此模型"
                  >
                    删除
                  </button>
                </div>
              ))}
            </div>
            
            <div className="bg-gray-100 p-3 rounded">
              <h5 className="font-medium text-sm mb-2">添加新模型</h5>
              <div className="space-y-2">
                <input
                  type="text"
                  value={newModelName}
                  onChange={(e) => setNewModelName(e.target.value)}
                  placeholder="模型名称 (比如: GPT-4)"
                  className="w-full px-3 py-2 border rounded text-sm"
                />
                <input
                  type="text"
                  value={newModelId}
                  onChange={(e) => setNewModelId(e.target.value)}
                  placeholder="模型ID (比如: gpt-4)"
                  className="w-full px-3 py-2 border rounded text-sm"
                />
                <button
                  onClick={addNewModel}
                  disabled={!newModelId.trim() || !newModelName.trim()}
                  className={`w-full py-2 rounded text-sm ${
                    !newModelId.trim() || !newModelName.trim()
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                      : 'bg-blue-500 text-white hover:bg-blue-600'
                  }`}
                >
                  添加模型
                </button>
              </div>
            </div>
          </div>

          <div className="flex items-center pt-2 border-t">
            <input
              type="checkbox"
              id="streamOutput"
              checked={settings.streamOutput}
              onChange={(e) => setSettings(prev => ({ ...prev, streamOutput: e.target.checked }))}
              className="mr-2"
            />
            <label htmlFor="streamOutput" className="text-sm font-medium text-gray-700">
              使用流式输出（逐字显示响应）
            </label>
          </div>
          
          {/* 对话命名设置 */}
          <div className="pt-4 border-t">
            <h4 className="font-medium text-gray-700 mb-2">对话命名设置</h4>
            
            <div className="space-y-3">
              <div className="flex items-center">
                <input
                  type="checkbox"
                  id="autoNameConversation"
                  checked={settings.autoNameConversation}
                  onChange={(e) => setSettings(prev => ({ 
                    ...prev, 
                    autoNameConversation: e.target.checked 
                  }))}
                  className="mr-2"
                />
                <label htmlFor="autoNameConversation" className="text-sm font-medium text-gray-700">
                  自动为新对话命名
                </label>
              </div>
              
              {settings.autoNameConversation && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    命名使用的模型
                  </label>
                  <select
                    value={settings.namingModel}
                    onChange={(e) => setSettings(prev => ({ ...prev, namingModel: e.target.value }))}
                    className="w-full px-3 py-2 border rounded text-sm"
                  >
                    {models.map(model => (
                      <option key={model.id} value={model.id}>
                        {model.name}
                      </option>
                    ))}
                  </select>
                  <p className="text-xs text-gray-500 mt-1">
                    推荐使用 GPT-3.5 Turbo，因为命名功能只需要基础理解能力，使用更快速的模型可以提高体验。
                  </p>
                </div>
              )}
            </div>
          </div>
          
          {/* 历史消息管理设置区域 */}
          <div className="pt-4 border-t">
            <h4 className="font-medium text-gray-700 mb-2">历史消息管理</h4>
            
            <div className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  每次请求附带历史消息数
                </label>
                <input
                  type="number"
                  value={settings.messageHistoryLimit}
                  onChange={(e) => setSettings(prev => ({ 
                    ...prev, 
                    messageHistoryLimit: Math.max(1, parseInt(e.target.value) || 1) 
                  }))}
                  min="1"
                  max="50"
                  className="w-full px-3 py-2 border rounded text-sm"
                />
                <p className="text-xs text-gray-500 mt-1">
                  值越小消耗的token越少，但可能缺失上下文信息。建议值：5-15
                </p>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  历史消息压缩阈值（字符数）
                </label>
                <input
                  type="number"
                  value={settings.messageCompressionThreshold}
                  onChange={(e) => setSettings(prev => ({ 
                    ...prev, 
                    messageCompressionThreshold: Math.max(500, parseInt(e.target.value) || 500) 
                  }))}
                  min="500"
                  className="w-full px-3 py-2 border rounded text-sm"
                />
                <p className="text-xs text-gray-500 mt-1">
                  当单条消息超过该字符数时会被压缩。建议值：1000-3000
                </p>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  id="enableHistorySummary"
                  checked={settings.enableHistorySummary}
                  onChange={(e) => setSettings(prev => ({ 
                    ...prev, 
                    enableHistorySummary: e.target.checked 
                  }))}
                  className="mr-2"
                />
                <label htmlFor="enableHistorySummary" className="text-sm font-medium text-gray-700">
                  启用历史对话摘要
                </label>
              </div>
              
              {settings.enableHistorySummary && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    历史摘要提示词
                  </label>
                  <textarea
                    value={settings.historySummaryPrompt}
                    onChange={(e) => setSettings(prev => ({ 
                      ...prev, 
                      historySummaryPrompt: e.target.value 
                    }))}
                    rows="3"
                    className="w-full px-3 py-2 border rounded text-sm"
                    placeholder="请总结前面的对话要点..."
                  />
                  <p className="text-xs text-gray-500 mt-1">
                    用于指导模型如何总结历史对话内容
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
        
        <button
          onClick={saveSettings}
          className="mt-6 w-full py-2 bg-green-500 text-white rounded hover:bg-green-600"
        >
          保存设置
        </button>
      </div>
    </div>
  );

  // 渲染历史记录视图（按最新顺序显示）
  const renderHistory = () => (
    <div className="flex flex-col h-full">
      {/* 固定的标题栏 */}
      <div className="p-3 border-b bg-gray-50 flex justify-between items-center">
        <h3 className="font-semibold">历史对话</h3>
        <button
          onClick={() => {
            createNewConversation();
            setCurrentView('chat');
          }}
          className="px-3 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
          title="开始新对话"
        >
          新对话
        </button>
      </div>
      
      {/* 可滚动的内容区域 */}
      <div className="flex-grow overflow-y-auto p-4 bg-gray-50">
        {conversations.length === 0 ? (
          <div className="text-center py-10">
            <p className="text-gray-500">暂无对话历史</p>
          </div>
        ) : (
          <div className="space-y-3">
            {/* 按创建时间排序，最新的在前面 */}
            {conversations
              .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
              .map(conv => {
                const modelInfo = models.find(m => m.id === conv.model) || { name: conv.model || '未知模型' };
                
                return (
                  <div key={conv.id} className="bg-white p-3 rounded shadow-sm">
                    <div className="flex justify-between items-start">
                      <div>
                        <h4 className="font-medium">{conv.title}</h4>
                        <p className="text-xs text-gray-500 mt-1">
                          {new Date(conv.createdAt).toLocaleString()} 
                          <span className="ml-2 px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full text-xs">
                            {modelInfo.name}
                          </span>
                        </p>
                      </div>
                      <div className="flex space-x-2">
                        <button
                          onClick={() => switchConversation(conv.id)}
                          className="px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600"
                        >
                          继续对话
                        </button>
                        <button
                          onClick={() => deleteConversation(conv.id)}
                          className="px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                        >
                          删除
                        </button>
                      </div>
                    </div>
                    <p className="text-sm text-gray-600 mt-2 truncate">
                      {conv.messages?.length > 0 
                        ? conv.messages[conv.messages.length - 1].content.substring(0, 50) + (conv.messages[conv.messages.length - 1].content.length > 50 ? '...' : '')
                        : '无消息'}
                    </p>
                    <p className="text-xs text-gray-500 mt-1">
                      {conv.messages?.length || 0} 条消息
                    </p>
                  </div>
                );
              })}
          </div>
        )}
      </div>
    </div>
  );

  // 渲染聊天视图
  const renderChat = () => (
    <>
      {/* 对话信息栏 */}
      <div className="p-3 border-b bg-gray-50 flex justify-between items-center">
        <h3 className="font-medium flex items-center">
          {currentConversationId 
            ? conversations.find(c => c.id === currentConversationId)?.title || '新对话'
            : '新对话'}
          {currentConversationId && 
           conversations.find(c => c.id === currentConversationId) && 
           !conversations.find(c => c.id === currentConversationId).isNamed && 
           settings.autoNameConversation && (
            <span className="ml-2 text-xs text-gray-500">(自动命名中...)</span>
          )}
        </h3>
        <div className="flex items-center space-x-2">
          <button
            onClick={createNewConversation}
            className="mr-2 px-3 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
            title="开始新对话"
          >
            新对话
          </button>
          
          <select
            value={selectedModel}
            onChange={(e) => handleChangeModel(e.target.value)}
            className="px-2 py-1 text-sm border rounded"
          >
            {models.map(model => (
              <option key={model.id} value={model.id}>{model.name}</option>
            ))}
          </select>
        </div>
      </div>
      
      {/* 消息区域 */}
      <div className="flex-grow overflow-y-auto p-4 bg-gray-100 stable-scroll-container">
        {messages.length === 0 ? (
          <div className="text-center text-gray-500 mt-10">
            发送一条消息开始对话...
          </div>
        ) : (
          <div className="space-y-4 messages-container">
            {/* 历史消息处理状态指示器 */}
            {(historyProcessingStatus.compressed || 
              historyProcessingStatus.summarized || 
              historyProcessingStatus.limitApplied) && (
              <div className="bg-blue-50 text-blue-800 p-2 rounded text-xs text-center">
                <p>使用优化后的上下文 ({historyProcessingStatus.processedCount}/{historyProcessingStatus.originalCount} 条消息)</p>
                <div className="flex justify-center space-x-2 mt-1">
                  {historyProcessingStatus.summarized && (
                    <span className="px-1.5 py-0.5 bg-blue-100 rounded">已生成摘要</span>
                  )}
                  {historyProcessingStatus.compressed && (
                    <span className="px-1.5 py-0.5 bg-blue-100 rounded">已压缩长消息</span>
                  )}
                  {historyProcessingStatus.limitApplied && (
                    <span className="px-1.5 py-0.5 bg-blue-100 rounded">已限制消息数量</span>
                  )}
                </div>
              </div>
            )}
            
            {messages.map((msg, index) => (
              <MessageItem key={msg.id || msg.timestamp || index} message={msg} index={index} />
            ))}
            <div ref={messagesEndRef} className="h-2 w-full" />
          </div>
        )}
      </div>
      
      {/* 可自动扩展高度的输入区域 */}
      <div className="p-3 border-t bg-white">
        <div className="flex">
          <div className="flex-grow relative">
            <textarea
              ref={inputRef}
              value={input}
              onChange={(e) => {
                setInput(e.target.value);
                // 自动调整高度
                e.target.style.height = 'auto';
                const newHeight = Math.min(Math.max(e.target.scrollHeight, 38), 150); // 最小38px，最大150px
                e.target.style.height = `${newHeight}px`;
              }}
              onKeyPress={(e) => e.key === 'Enter' && !e.shiftKey && (e.preventDefault(), handleSendMessage())}
              placeholder="输入您的问题... (Shift+Enter换行)"
              className="w-full px-4 py-2 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none overflow-auto"
              disabled={isLoading}
              rows="1"
              style={{ minHeight: '38px', maxHeight: '150px' }}
            />
          </div>
          <button
            onClick={isStreaming ? handleAbortRequest : handleSendMessage}
            disabled={(!input.trim() && !isStreaming) || (isLoading && !isStreaming)}
            className={`px-4 py-2 flex items-center justify-center rounded-r-lg self-stretch ${
              (!input.trim() && !isStreaming) || (isLoading && !isStreaming)
                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                : isStreaming
                  ? 'bg-red-500 text-white hover:bg-red-600'
                  : 'bg-blue-500 text-white hover:bg-blue-600'
            }`}
          >
            {isLoading ? (
              isStreaming ? (
                "停止"
              ) : (
                <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
              )
            ) : (
              "➤"
            )}
          </button>
        </div>
      </div>
    </>
  );

  return (
    <>
      {/* 侧边栏切换按钮 */}
      <button
        className="fixed right-4 top-24 z-50 bg-blue-500 hover:bg-blue-600 text-white rounded-full p-3 shadow-lg transition-all duration-300"
        onClick={() => setIsOpen(prev => !prev)}
        title={isOpen ? "关闭助手" : "打开助手"}
      >
        {isOpen ? "✕" : "��"}
      </button>
      
      {/* 侧边栏 */}
      <div
        ref={sidebarRef}
        className={`